\section{File List}
Here is a list of all files with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{Models/\+Formal\+Language\+Theory-\/\+Complex/\hyperlink{_data_8h}{Data.\+h} }{\pageref{_data_8h}}{}
\item\contentsline{section}{Models/\+Formal\+Language\+Theory-\/\+Complex/\hyperlink{_formal_language_theory-_complex_2_main_8cpp}{Main.\+cpp} }{\pageref{_formal_language_theory-_complex_2_main_8cpp}}{}
\item\contentsline{section}{Models/\+Formal\+Language\+Theory-\/\+Simple/\hyperlink{_formal_language_theory-_simple_2_main_8cpp}{Main.\+cpp} }{\pageref{_formal_language_theory-_simple_2_main_8cpp}}{}
\item\contentsline{section}{Models/\+Number-\/\+Fancy/\hyperlink{_number-_fancy_2_main_8cpp}{Main.\+cpp} }{\pageref{_number-_fancy_2_main_8cpp}}{}
\item\contentsline{section}{Models/\+Number\+Game/\hyperlink{_number_game_2_main_8cpp}{Main.\+cpp} }{\pageref{_number_game_2_main_8cpp}}{}
\item\contentsline{section}{Models/\+Rational\+Rules/\hyperlink{_rational_rules_2_main_8cpp}{Main.\+cpp} }{\pageref{_rational_rules_2_main_8cpp}}{}
\item\contentsline{section}{src/\hyperlink{_control_8h}{Control.\+h} \\*This bundles together information for running M\+C\+MC or M\+C\+TS, including number of steps, amount of time, etc. N\+O\+TE\+: In general this should N\+OT be passed by reference because we want start\+\_\+time to be the time we started the function it is passed to (start time is the time of construction, here) }{\pageref{_control_8h}}{}
\item\contentsline{section}{src/\hyperlink{_discrete_distribution_8h}{Discrete\+Distribution.\+h} \\*This stores a distribution from values of T to log probabilities. It is used as the return value from calls with randomness }{\pageref{_discrete_distribution_8h}}{}
\item\contentsline{section}{src/\hyperlink{_eigen_numerics_8h}{Eigen\+Numerics.\+h} }{\pageref{_eigen_numerics_8h}}{}
\item\contentsline{section}{src/\hyperlink{_fleet_8h}{Fleet.\+h} }{\pageref{_fleet_8h}}{}
\item\contentsline{section}{src/\hyperlink{_grammar_8h}{Grammar.\+h} }{\pageref{_grammar_8h}}{}
\item\contentsline{section}{src/\hyperlink{_hash_8h}{Hash.\+h} }{\pageref{_hash_8h}}{}
\item\contentsline{section}{src/\hyperlink{_integerized_stack_8h}{Integerized\+Stack.\+h} }{\pageref{_integerized_stack_8h}}{}
\item\contentsline{section}{src/\hyperlink{_i_o_8h}{I\+O.\+h} }{\pageref{_i_o_8h}}{}
\item\contentsline{section}{src/\hyperlink{_miscellaneous_8h}{Miscellaneous.\+h} }{\pageref{_miscellaneous_8h}}{}
\item\contentsline{section}{src/\hyperlink{_node_8h}{Node.\+h} }{\pageref{_node_8h}}{}
\item\contentsline{section}{src/\hyperlink{_nonterminal_8h}{Nonterminal.\+h} }{\pageref{_nonterminal_8h}}{}
\item\contentsline{section}{src/\hyperlink{_numerics_8h}{Numerics.\+h} }{\pageref{_numerics_8h}}{}
\item\contentsline{section}{src/\hyperlink{_program_8h}{Program.\+h} }{\pageref{_program_8h}}{}
\item\contentsline{section}{src/\hyperlink{_random_8h}{Random.\+h} }{\pageref{_random_8h}}{}
\item\contentsline{section}{src/\hyperlink{_rule_8h}{Rule.\+h} \\*A \hyperlink{class_rule}{Rule} stores one possible expansion in the grammar, specifying a nonterminal type, an instruction that gets executed, a forma string, a number of children, and an array of types of each child. Here we \char`\"{}emulate\char`\"{} a type system using t\+\_\+nonterminal to store an integer for the types. $\ast$ }{\pageref{_rule_8h}}{}
\item\contentsline{section}{src/\hyperlink{_stack_8h}{Stack.\+h} }{\pageref{_stack_8h}}{}
\item\contentsline{section}{src/\hyperlink{_strings_8h}{Strings.\+h} }{\pageref{_strings_8h}}{}
\item\contentsline{section}{src/\hyperlink{_template_magic_8h}{Template\+Magic.\+h} }{\pageref{_template_magic_8h}}{}
\item\contentsline{section}{src/\hyperlink{_timing_8h}{Timing.\+h} }{\pageref{_timing_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\hyperlink{_datum_8h}{Datum.\+h} \\*A datum is the default data point for likelihoods, consisting of an input and output type. The reliability is measures the reliability of the data (sometimes number of effective data points, sometimes its the noise in the likelihood }{\pageref{_datum_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\hyperlink{_grammar_hypothesis_8h}{Grammar\+Hypothesis.\+h} }{\pageref{_grammar_hypothesis_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\hyperlink{_lexicon_8h}{Lexicon.\+h} \\*A lexicon stores an association of numbers (in a vector) to some other kind of hypotheses (typically a \hyperlink{class_l_o_t_hypothesis}{L\+O\+T\+Hypothesis}). Each of these components is called a \char`\"{}factor.\char`\"{} }{\pageref{_lexicon_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\hyperlink{_l_o_t_hypothesis_8h}{L\+O\+T\+Hypothesis.\+h} }{\pageref{_l_o_t_hypothesis_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\hyperlink{_proposers_8h}{Proposers.\+h} }{\pageref{_proposers_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\+Interfaces/\hyperlink{_bayesable_8h}{Bayesable.\+h} \\*The \hyperlink{class_bayesable}{Bayesable} class provides an interface for hypotheses that support Bayesian inference (e.\+g. computing priors, likelihoods, and posteriors) Note that this class stores prior, likelihood, posterior always at temperature 1.\+0, and you can get the values of the posterior at other temperatures via \hyperlink{class_bayesable_ac9ba96f829785f07919610941077b4c9}{Bayesable.\+at\+\_\+temperature(double t)} }{\pageref{_bayesable_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\+Interfaces/\hyperlink{_dispatchable_8h}{Dispatchable.\+h} \\*A class is dispatchable if it is able to implement custom operations and put its program onto a Program }{\pageref{_dispatchable_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\+Interfaces/\hyperlink{_m_c_m_cable_8h}{M\+C\+M\+Cable.\+h} \\*A class is \hyperlink{class_m_c_m_cable}{M\+C\+M\+Cable} if it is \hyperlink{class_bayesable}{Bayesable} and lets us propose, restart, and check equality (which M\+C\+MC does for speed) }{\pageref{_m_c_m_cable_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\+Interfaces/\hyperlink{_searchable_8h}{Searchable.\+h} \\*A class is searchable if permits us to enumerate and make its neighbors. This class is used by M\+C\+TS and allows us to incrementally search a hypothesis }{\pageref{_searchable_8h}}{}
\item\contentsline{section}{src/\+Inference/\hyperlink{_chain_pool_8h}{Chain\+Pool.\+h} \\*A \hyperlink{class_chain_pool}{Chain\+Pool} stores a bunch of M\+C\+M\+C\+Chains and allows you to run them serially or in parallel }{\pageref{_chain_pool_8h}}{}
\item\contentsline{section}{src/\+Inference/\hyperlink{_enumeration_8h}{Enumeration.\+h} }{\pageref{_enumeration_8h}}{}
\item\contentsline{section}{src/\+Inference/\hyperlink{_m_c_m_c_chain_8h}{M\+C\+M\+C\+Chain.\+h} }{\pageref{_m_c_m_c_chain_8h}}{}
\item\contentsline{section}{src/\+Inference/\hyperlink{_m_c_t_s_8h}{M\+C\+T\+S.\+h} \\*Template of self type M, hypothesis type H\+YP. This requires us to inherit and override playout to do whatever we want }{\pageref{_m_c_t_s_8h}}{}
\item\contentsline{section}{src/\+Inference/\hyperlink{_parallel_tempering_8h}{Parallel\+Tempering.\+h} }{\pageref{_parallel_tempering_8h}}{}
\item\contentsline{section}{src/\+Statistics/\hyperlink{_finite_history_8h}{Finite\+History.\+h} \\*A Finite\+History stores the previous N examples of something of type T. This is used e.\+g. in M\+C\+MC in order to count the acceptance ratio on the previous N samples }{\pageref{_finite_history_8h}}{}
\item\contentsline{section}{src/\+Statistics/\hyperlink{_median_f_a_m_e_8h}{Median\+F\+A\+M\+E.\+h} \\*A streaming median class implementing the F\+A\+ME algorithm Here, we initialize both the step size and M with the current sample \href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.108.7376&rep=rep1&type=pdf}{\tt http\+://citeseerx.\+ist.\+psu.\+edu/viewdoc/download?doi=10.\+1.\+1.\+108.\+7376\&rep=rep1\&type=pdf} }{\pageref{_median_f_a_m_e_8h}}{}
\item\contentsline{section}{src/\+Statistics/\hyperlink{_reservoir_sample_8h}{Reservoir\+Sample.\+h} \\*A reservoir sampling algorithm. N\+O\+TE\+: This was simplified from an old version that permitted unequal weights among elements. We may go back to that eventually -\/ \href{https://en.wikipedia.org/wiki/Reservoir_sampling#Weighted_random_sampling_}{\tt https\+://en.\+wikipedia.\+org/wiki/\+Reservoir\+\_\+sampling\#\+Weighted\+\_\+random\+\_\+sampling\+\_\+} }{\pageref{_reservoir_sample_8h}}{}
\item\contentsline{section}{src/\+Statistics/\hyperlink{_reservoir_sample__old_8h}{Reservoir\+Sample\+\_\+old.\+h} }{\pageref{_reservoir_sample__old_8h}}{}
\item\contentsline{section}{src/\+Statistics/\hyperlink{_streaming_statistics_8h}{Streaming\+Statistics.\+h} \\*A class to store a bunch of statistics about incoming data points, including min, max, mean, etc. This also stores a reservoir sample and allow us to compute how often one distribution exceeds another }{\pageref{_streaming_statistics_8h}}{}
\item\contentsline{section}{src/\+Statistics/\hyperlink{_top_8h}{Top.\+h} \\*A TopN is a n object you can \char`\"{}add\char`\"{} hypotheses to (via add or $<$$<$) and it stores the best N of them. This is widely used in \hyperlink{namespace_fleet}{Fleet} in order to find good approximations to the top hypotheses found in M\+C\+TS or M\+C\+MC }{\pageref{_top_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\hyperlink{_builtins_8h}{Builtins.\+h} }{\pageref{_builtins_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\hyperlink{_case_macros_8h}{Case\+Macros.\+h} }{\pageref{_case_macros_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\hyperlink{_instruction_8h}{Instruction.\+h} \\*This is an error type that is returned if we get a runtime error (e.\+g. string length, etc.) }{\pageref{_instruction_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\hyperlink{_primitives_8h}{Primitives.\+h} \\*A preprimitive is a class that primitives inherit. We use a static op\+\_\+counter so that at compile time thsi can be used to compute an op number for each separate primitive }{\pageref{_primitives_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\hyperlink{_primitives2_8h}{Primitives2.\+h} }{\pageref{_primitives2_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\hyperlink{_virtual_machine_pool_8h}{Virtual\+Machine\+Pool.\+h} \\*This manages a collection of Virtual\+Machines -- this is what handles the enumeration of flip by probability. Basically each machine state stores the state of some evaluator and is able to push things back on to the Q if it encounters a random flip This stores pointers because it is impossible to copy out of std collections, so we are constantly having to call \hyperlink{class_virtual_machine_state}{Virtual\+Machine\+State} constructors. Using pointers speeds us up by about 20\% }{\pageref{_virtual_machine_pool_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\hyperlink{_virtual_machine_state_8h}{Virtual\+Machine\+State.\+h} \\*This represents the state of a partial evaluation of a program, corresponding to the value of all of the stacks of various types (which are stored as templates from F\+L\+E\+E\+T\+\_\+\+G\+R\+A\+M\+M\+A\+R\+\_\+\+T\+Y\+P\+ES). The idea here is that we want to be able to encapsulate everything about the evaluation of a tree so that we can stop it in the middle and resume later, as is required for stochastics. This must be templated because it depends on the types in the grammar. These will typically be stored in a \hyperlink{class_virtual_machine_pool}{Virtual\+Machine\+Pool} and not called directly, unless you know that there are no stochastics }{\pageref{_virtual_machine_state_8h}}{}
\end{DoxyCompactList}
