<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fleet: Grammar Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_sm.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fleet
   &#160;<span id="projectnumber">0.0.9</span>
   </div>
   <div id="projectbrief">Inference in the LOT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_grammar-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Grammar Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_grammar_8h_source.html">Grammar.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa5c9afa0e7e1aa989b54402b02a677a3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa5c9afa0e7e1aa989b54402b02a677a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr nonterminal_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a> ()</td></tr>
<tr class="separator:aa5c9afa0e7e1aa989b54402b02a677a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa201250a002a7d07d398fee189a74427"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#aa201250a002a7d07d398fee189a74427">Grammar</a> ()</td></tr>
<tr class="separator:aa201250a002a7d07d398fee189a74427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0a3b86d64eba75726b7355308c4649"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a4e0a3b86d64eba75726b7355308c4649"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#a4e0a3b86d64eba75726b7355308c4649">Grammar</a> (std::tuple&lt; T... &gt; tup)</td></tr>
<tr class="separator:a4e0a3b86d64eba75726b7355308c4649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb7e4ea64210d03de896e300447e760"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#acfb7e4ea64210d03de896e300447e760">Grammar</a> (const <a class="el" href="class_grammar.html">Grammar</a> &amp;g)=delete</td></tr>
<tr class="separator:acfb7e4ea64210d03de896e300447e760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f97335602afe8b1a612679de2f80d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a28f97335602afe8b1a612679de2f80d9">Grammar</a> (const <a class="el" href="class_grammar.html">Grammar</a> &amp;&amp;g)=delete</td></tr>
<tr class="separator:a28f97335602afe8b1a612679de2f80d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf841bc64ac19cb9872a8362f5e5731a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#abf841bc64ac19cb9872a8362f5e5731a">count_nonterminals</a> () const</td></tr>
<tr class="separator:abf841bc64ac19cb9872a8362f5e5731a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25c47a2c5cae2a11720c8454e59290f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#af25c47a2c5cae2a11720c8454e59290f">count_rules</a> (const nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>) const</td></tr>
<tr class="separator:af25c47a2c5cae2a11720c8454e59290f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f0fdd9cb368a608bee5626774360d4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#af8f0fdd9cb368a608bee5626774360d4">count_rules</a> () const</td></tr>
<tr class="separator:af8f0fdd9cb368a608bee5626774360d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf0515f3ca761590da05455a417896b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a7cf0515f3ca761590da05455a417896b">count_terminals</a> (nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>) const</td></tr>
<tr class="separator:a7cf0515f3ca761590da05455a417896b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0714d68070749932d876fe868bde94bd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a0714d68070749932d876fe868bde94bd">count_nonterminals</a> (nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>) const</td></tr>
<tr class="separator:a0714d68070749932d876fe868bde94bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c015fe6f16191ddb2f21a51f1931a05"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a9c015fe6f16191ddb2f21a51f1931a05">count_expansions</a> (const nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>) const</td></tr>
<tr class="separator:a9c015fe6f16191ddb2f21a51f1931a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c730ea64c8ca5d93fecb4275f2e380"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#aa3c730ea64c8ca5d93fecb4275f2e380">show</a> (std::string prefix=&quot;# &quot;)</td></tr>
<tr class="separator:aa3c730ea64c8ca5d93fecb4275f2e380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b97cbaf14fc6be7495c8bb9e888002"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#af0b97cbaf14fc6be7495c8bb9e888002">add</a> (<a class="el" href="class_rule.html">Rule</a> &amp;&amp;r)</td></tr>
<tr class="separator:af0b97cbaf14fc6be7495c8bb9e888002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a1dd90b7a315fe97bbdefad7c09df9"><td class="memTemplParams" colspan="2">template&lt;typename... args, size_t... Is&gt; </td></tr>
<tr class="memitem:a37a1dd90b7a315fe97bbdefad7c09df9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#a37a1dd90b7a315fe97bbdefad7c09df9">add</a> (std::tuple&lt; args... &gt; t, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="separator:a37a1dd90b7a315fe97bbdefad7c09df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af8f369b948cde8ee5d403311ec8fa9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... args&gt; </td></tr>
<tr class="memitem:a0af8f369b948cde8ee5d403311ec8fa9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#a0af8f369b948cde8ee5d403311ec8fa9">add</a> (<a class="el" href="struct_primitive.html">Primitive</a>&lt; T, args... &gt; p, const int arg=0)</td></tr>
<tr class="separator:a0af8f369b948cde8ee5d403311ec8fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96467de4413d3e5a0d2f291992365d9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... args&gt; </td></tr>
<tr class="memitem:af96467de4413d3e5a0d2f291992365d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#af96467de4413d3e5a0d2f291992365d9">add</a> (<a class="el" href="struct_builtin_primitive.html">BuiltinPrimitive</a>&lt; T, args... &gt; p, const int arg=0)</td></tr>
<tr class="separator:af96467de4413d3e5a0d2f291992365d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562f3b4113e3f2764832ac828ffb58fc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... args&gt; </td></tr>
<tr class="memitem:a562f3b4113e3f2764832ac828ffb58fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#a562f3b4113e3f2764832ac828ffb58fc">add</a> (<a class="el" href="_instruction_8h.html#af2fb7c87c5854c5733d7bb0506b06de7">BuiltinOp</a> o, std::string format, const double p=1.0, const int arg=0)</td></tr>
<tr class="separator:a562f3b4113e3f2764832ac828ffb58fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba61b4a7563c249a27ad7b6b808ee575"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... args&gt; </td></tr>
<tr class="memitem:aba61b4a7563c249a27ad7b6b808ee575"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#aba61b4a7563c249a27ad7b6b808ee575">add</a> (<a class="el" href="_instruction_8h.html#a3a20ca4a8f0ab220518b030cc23ffee4">CustomOp</a> o, std::string format, const double p=1.0, const int arg=0)</td></tr>
<tr class="separator:aba61b4a7563c249a27ad7b6b808ee575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affec19f6e91201c8d29119bf50ffa3e6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#affec19f6e91201c8d29119bf50ffa3e6">get_index_of</a> (const <a class="el" href="class_rule.html">Rule</a> *r) const</td></tr>
<tr class="separator:affec19f6e91201c8d29119bf50ffa3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea24b7ae4a2d61f322504a9f49478bb4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#aea24b7ae4a2d61f322504a9f49478bb4">get_rule</a> (const nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>, size_t k) const</td></tr>
<tr class="separator:aea24b7ae4a2d61f322504a9f49478bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa642e370571830772b8d3be70cb5a5c7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#aa642e370571830772b8d3be70cb5a5c7">get_rule</a> (const nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>, const <a class="el" href="_instruction_8h.html#a3a20ca4a8f0ab220518b030cc23ffee4">CustomOp</a> o, const int a=0)</td></tr>
<tr class="separator:aa642e370571830772b8d3be70cb5a5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82ed6614e4fcced4d0e7c742e1c5e4b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#ab82ed6614e4fcced4d0e7c742e1c5e4b">get_rule</a> (const nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>, const <a class="el" href="_instruction_8h.html#af2fb7c87c5854c5733d7bb0506b06de7">BuiltinOp</a> o, const int a=0)</td></tr>
<tr class="separator:ab82ed6614e4fcced4d0e7c742e1c5e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0198e1a6c052fad5cba950e0ad60d67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#ae0198e1a6c052fad5cba950e0ad60d67">get_rule</a> (const nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>, const std::string s) const</td></tr>
<tr class="separator:ae0198e1a6c052fad5cba950e0ad60d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecdec03b3211bd3b6800511c7ed5dd9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#adecdec03b3211bd3b6800511c7ed5dd9">get_rule</a> (const std::string s) const</td></tr>
<tr class="separator:adecdec03b3211bd3b6800511c7ed5dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2182b3ded5171ba3e84be952176798e9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a2182b3ded5171ba3e84be952176798e9">rule_normalizer</a> (const nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>) const</td></tr>
<tr class="separator:a2182b3ded5171ba3e84be952176798e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c30e020e54743d5ede0ca9469fdb91"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a50c30e020e54743d5ede0ca9469fdb91">sample_rule</a> (const nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>) const</td></tr>
<tr class="separator:a50c30e020e54743d5ede0ca9469fdb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d60795be5b288d74a87f2cc52008f71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a5d60795be5b288d74a87f2cc52008f71">makeNode</a> (const <a class="el" href="class_rule.html">Rule</a> *r) const</td></tr>
<tr class="separator:a5d60795be5b288d74a87f2cc52008f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a08c44dbbba7406d3638bdc549fddad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a6a08c44dbbba7406d3638bdc549fddad">generate</a> (const nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>, unsigned long depth=0) const</td></tr>
<tr class="separator:a6a08c44dbbba7406d3638bdc549fddad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4cda199ab92f79b55e73f6cbd90c8b"><td class="memTemplParams" colspan="2">template&lt;class t &gt; </td></tr>
<tr class="memitem:aee4cda199ab92f79b55e73f6cbd90c8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#aee4cda199ab92f79b55e73f6cbd90c8b">generate</a> (unsigned long depth=0)</td></tr>
<tr class="separator:aee4cda199ab92f79b55e73f6cbd90c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6333cce88a2fe7ce56a897a6a930c28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#ad6333cce88a2fe7ce56a897a6a930c28">copy_resample</a> (const <a class="el" href="class_node.html">Node</a> &amp;node, bool f(const <a class="el" href="class_node.html">Node</a> &amp;n)) const</td></tr>
<tr class="separator:ad6333cce88a2fe7ce56a897a6a930c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0823f7af30a851a968dae46adbd49a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#ae0823f7af30a851a968dae46adbd49a5">get_counts</a> (const <a class="el" href="class_node.html">Node</a> &amp;node) const</td></tr>
<tr class="separator:ae0823f7af30a851a968dae46adbd49a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f1788026f68e7ddb7fca1ec04915f5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a11f1788026f68e7ddb7fca1ec04915f5">log_probability</a> (const <a class="el" href="class_node.html">Node</a> &amp;n) const</td></tr>
<tr class="separator:a11f1788026f68e7ddb7fca1ec04915f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bd3d35545bcab4dbd3ca1d136bd4ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#ab5bd3d35545bcab4dbd3ca1d136bd4ce">expand_from_names</a> (std::deque&lt; std::string &gt; &amp;q) const</td></tr>
<tr class="separator:ab5bd3d35545bcab4dbd3ca1d136bd4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44954a36c11d58c23bef02ca7d541005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a44954a36c11d58c23bef02ca7d541005">expand_from_names</a> (std::string s) const</td></tr>
<tr class="separator:a44954a36c11d58c23bef02ca7d541005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0addff494602ebb19852c2d4314eaac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a0addff494602ebb19852c2d4314eaac6">expand_from_names</a> (const char *c) const</td></tr>
<tr class="separator:a0addff494602ebb19852c2d4314eaac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221f1a43488624ce78138d7d5045a816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a221f1a43488624ce78138d7d5045a816">expand_from_integer</a> (nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>, <a class="el" href="class_integerized_stack.html">IntegerizedStack</a> &amp;is) const</td></tr>
<tr class="separator:a221f1a43488624ce78138d7d5045a816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b478d4ad5955b7489074e106afce5a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a7b478d4ad5955b7489074e106afce5a4">expand_from_integer</a> (nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>, <a class="el" href="_numerics_8h.html#a9fe2bbca873b046b2bd276fc6856bb88">enumerationidx_t</a> z) const</td></tr>
<tr class="separator:a7b478d4ad5955b7489074e106afce5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6970c88fc6f5ed56020fe0dfac302f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_numerics_8h.html#a9fe2bbca873b046b2bd276fc6856bb88">enumerationidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#ab6970c88fc6f5ed56020fe0dfac302f4">compute_enumeration_order</a> (const <a class="el" href="class_node.html">Node</a> &amp;n)</td></tr>
<tr class="separator:ab6970c88fc6f5ed56020fe0dfac302f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607aa205d57a1b61b07f9ef57adcf697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a607aa205d57a1b61b07f9ef57adcf697">lempel_ziv_full_expand</a> (nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>, <a class="el" href="_numerics_8h.html#a9fe2bbca873b046b2bd276fc6856bb88">enumerationidx_t</a> z, <a class="el" href="class_node.html">Node</a> *root=nullptr) const</td></tr>
<tr class="separator:a607aa205d57a1b61b07f9ef57adcf697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fd19c7b9c1d92c59365a693ec12547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a98fd19c7b9c1d92c59365a693ec12547">lempel_ziv_full_expand</a> (nonterminal_t <a class="el" href="class_grammar.html#aa5c9afa0e7e1aa989b54402b02a677a3">nt</a>, <a class="el" href="class_integerized_stack.html">IntegerizedStack</a> &amp;is, <a class="el" href="class_node.html">Node</a> *root=nullptr) const</td></tr>
<tr class="separator:a98fd19c7b9c1d92c59365a693ec12547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56da50581cbebe1427ebf2f73018328"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_numerics_8h.html#a9fe2bbca873b046b2bd276fc6856bb88">enumerationidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#ad56da50581cbebe1427ebf2f73018328">count_connected_partial_subtrees</a> (const <a class="el" href="class_node.html">Node</a> &amp;n) const</td></tr>
<tr class="separator:ad56da50581cbebe1427ebf2f73018328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9115c2743b054ec44ef513843d84f5d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#ae9115c2743b054ec44ef513843d84f5d">neighbors</a> (const <a class="el" href="class_node.html">Node</a> &amp;node) const</td></tr>
<tr class="separator:ae9115c2743b054ec44ef513843d84f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd380ec308907ddc26acb22196610b83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#abd380ec308907ddc26acb22196610b83">expand_to_neighbor</a> (<a class="el" href="class_node.html">Node</a> &amp;node, int &amp;which)</td></tr>
<tr class="separator:abd380ec308907ddc26acb22196610b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f767b06f9675461be94242c89dfdb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a68f767b06f9675461be94242c89dfdb9">complete</a> (<a class="el" href="class_node.html">Node</a> &amp;node)</td></tr>
<tr class="separator:a68f767b06f9675461be94242c89dfdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aae1036bcd35025ff7512252c7aa06e9c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_rule.html">Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#aae1036bcd35025ff7512252c7aa06e9c">rules</a> [N_NTs]</td></tr>
<tr class="separator:aae1036bcd35025ff7512252c7aa06e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55b1376566113fecd05b2c99b9f0014"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#af55b1376566113fecd05b2c99b9f0014">Z</a> [N_NTs]</td></tr>
<tr class="separator:af55b1376566113fecd05b2c99b9f0014"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa201250a002a7d07d398fee189a74427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa201250a002a7d07d398fee189a74427">&#9670;&nbsp;</a></span>Grammar() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Grammar::Grammar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e0a3b86d64eba75726b7355308c4649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0a3b86d64eba75726b7355308c4649">&#9670;&nbsp;</a></span>Grammar() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Grammar::Grammar </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; T... &gt;&#160;</td>
          <td class="paramname"><em>tup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor for grammar that uses a tuple of Primitives. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tup</td><td>- a tuple of Primitives</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfb7e4ea64210d03de896e300447e760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb7e4ea64210d03de896e300447e760">&#9670;&nbsp;</a></span>Grammar() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Grammar::Grammar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_grammar.html">Grammar</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28f97335602afe8b1a612679de2f80d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f97335602afe8b1a612679de2f80d9">&#9670;&nbsp;</a></span>Grammar() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Grammar::Grammar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_grammar.html">Grammar</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af0b97cbaf14fc6be7495c8bb9e888002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b97cbaf14fc6be7495c8bb9e888002">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Grammar::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rule.html">Rule</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a rule</p>

</div>
</div>
<a id="a37a1dd90b7a315fe97bbdefad7c09df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a1dd90b7a315fe97bbdefad7c09df9">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... args, size_t... Is&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Grammar::add </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; args... &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0af8f369b948cde8ee5d403311ec8fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af8f369b948cde8ee5d403311ec8fa9">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Grammar::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_primitive.html">Primitive</a>&lt; T, args... &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>arg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af96467de4413d3e5a0d2f291992365d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96467de4413d3e5a0d2f291992365d9">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Grammar::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_builtin_primitive.html">BuiltinPrimitive</a>&lt; T, args... &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>arg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a562f3b4113e3f2764832ac828ffb58fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562f3b4113e3f2764832ac828ffb58fc">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Grammar::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_instruction_8h.html#af2fb7c87c5854c5733d7bb0506b06de7">BuiltinOp</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>p</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>arg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba61b4a7563c249a27ad7b6b808ee575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba61b4a7563c249a27ad7b6b808ee575">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Grammar::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_instruction_8h.html#a3a20ca4a8f0ab220518b030cc23ffee4">CustomOp</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>p</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>arg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68f767b06f9675461be94242c89dfdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f767b06f9675461be94242c89dfdb9">&#9670;&nbsp;</a></span>complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Grammar::complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6970c88fc6f5ed56020fe0dfac302f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6970c88fc6f5ed56020fe0dfac302f4">&#9670;&nbsp;</a></span>compute_enumeration_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_numerics_8h.html#a9fe2bbca873b046b2bd276fc6856bb88">enumerationidx_t</a> Grammar::compute_enumeration_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6333cce88a2fe7ce56a897a6a930c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6333cce88a2fe7ce56a897a6a930c28">&#9670;&nbsp;</a></span>copy_resample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> Grammar::copy_resample </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>f</em>const Node &amp;n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a copy of node where all nodes satisfying f are regenerated from the grammar. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">f</td><td>- a function saying what we should resample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOTE: this does NOT allow f to apply to nullptr children (so cannot be used to fill in)</dd></dl>

</div>
</div>
<a id="ad56da50581cbebe1427ebf2f73018328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56da50581cbebe1427ebf2f73018328">&#9670;&nbsp;</a></span>count_connected_partial_subtrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="_numerics_8h.html#a9fe2bbca873b046b2bd276fc6856bb88">enumerationidx_t</a> Grammar::count_connected_partial_subtrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c015fe6f16191ddb2f21a51f1931a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c015fe6f16191ddb2f21a51f1931a05">&#9670;&nbsp;</a></span>count_expansions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Grammar::count_expansions </td>
          <td>(</td>
          <td class="paramtype">const nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf841bc64ac19cb9872a8362f5e5731a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf841bc64ac19cb9872a8362f5e5731a">&#9670;&nbsp;</a></span>count_nonterminals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Grammar::count_nonterminals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>How many nonterminals are there in the grammar. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a0714d68070749932d876fe868bde94bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0714d68070749932d876fe868bde94bd">&#9670;&nbsp;</a></span>count_nonterminals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Grammar::count_nonterminals </td>
          <td>(</td>
          <td class="paramtype">nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count th enumber of non-terminal rules of return type nt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af25c47a2c5cae2a11720c8454e59290f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25c47a2c5cae2a11720c8454e59290f">&#9670;&nbsp;</a></span>count_rules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Grammar::count_rules </td>
          <td>(</td>
          <td class="paramtype">const nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of rules of return type nt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af8f0fdd9cb368a608bee5626774360d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f0fdd9cb368a608bee5626774360d4">&#9670;&nbsp;</a></span>count_rules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Grammar::count_rules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of rules </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7cf0515f3ca761590da05455a417896b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf0515f3ca761590da05455a417896b">&#9670;&nbsp;</a></span>count_terminals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Grammar::count_terminals </td>
          <td>(</td>
          <td class="paramtype">nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the number of terminal rules of return type nt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a221f1a43488624ce78138d7d5045a816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221f1a43488624ce78138d7d5045a816">&#9670;&nbsp;</a></span>expand_from_integer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> Grammar::expand_from_integer </td>
          <td>(</td>
          <td class="paramtype">nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_integerized_stack.html">IntegerizedStack</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b478d4ad5955b7489074e106afce5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b478d4ad5955b7489074e106afce5a4">&#9670;&nbsp;</a></span>expand_from_integer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> Grammar::expand_from_integer </td>
          <td>(</td>
          <td class="paramtype">nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_numerics_8h.html#a9fe2bbca873b046b2bd276fc6856bb88">enumerationidx_t</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5bd3d35545bcab4dbd3ca1d136bd4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5bd3d35545bcab4dbd3ca1d136bd4ce">&#9670;&nbsp;</a></span>expand_from_names() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> Grammar::expand_from_names </td>
          <td>(</td>
          <td class="paramtype">std::deque&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills an entire tree using the string format prefixes &ndash; see get_rule(std::string). Here q should contain strings like "3:'a'" which says expand nonterminal type 3 to the rule matching 'a' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a44954a36c11d58c23bef02ca7d541005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44954a36c11d58c23bef02ca7d541005">&#9670;&nbsp;</a></span>expand_from_names() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> Grammar::expand_from_names </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Expand from names where s is delimited by ':' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a0addff494602ebb19852c2d4314eaac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0addff494602ebb19852c2d4314eaac6">&#9670;&nbsp;</a></span>expand_from_names() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> Grammar::expand_from_names </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd380ec308907ddc26acb22196610b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd380ec308907ddc26acb22196610b83">&#9670;&nbsp;</a></span>expand_to_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Grammar::expand_to_neighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a08c44dbbba7406d3638bdc549fddad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a08c44dbbba7406d3638bdc549fddad">&#9670;&nbsp;</a></span>generate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> Grammar::generate </td>
          <td>(</td>
          <td class="paramtype">const nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sample an entire tree from this grammar (keeping track of depth in case we recurse too far) of return type nt. This samples a rule, makes them with makeNode, and then recurses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
    <tr><td class="paramname">depth</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="class_node.html">Node</a> sampled from the grammar.</dd></dl>
<p>NOTE: this may throw a <a class="el" href="class_depth_exception.html">DepthException</a> if the grammar recurses too far (usually that means the grammar is improper)</p>

</div>
</div>
<a id="aee4cda199ab92f79b55e73f6cbd90c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4cda199ab92f79b55e73f6cbd90c8b">&#9670;&nbsp;</a></span>generate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> Grammar::generate </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A friendly version of generate that can be called with template by type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae0823f7af30a851a968dae46adbd49a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0823f7af30a851a968dae46adbd49a5">&#9670;&nbsp;</a></span>get_counts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; Grammar::get_counts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a vector of counts of how often each rule was used, in a <em>standard</em> order given by iterating over nts and then iterating over rules </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="affec19f6e91201c8d29119bf50ffa3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affec19f6e91201c8d29119bf50ffa3e6">&#9670;&nbsp;</a></span>get_index_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Grammar::get_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule.html">Rule</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the index in rules of where r is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aea24b7ae4a2d61f322504a9f49478bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea24b7ae4a2d61f322504a9f49478bb4">&#9670;&nbsp;</a></span>get_rule() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_rule.html">Rule</a>* Grammar::get_rule </td>
          <td>(</td>
          <td class="paramtype">const nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the k'th rule of type nt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
    <tr><td class="paramname">k</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa642e370571830772b8d3be70cb5a5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa642e370571830772b8d3be70cb5a5c7">&#9670;&nbsp;</a></span>get_rule() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_rule.html">Rule</a>* Grammar::get_rule </td>
          <td>(</td>
          <td class="paramtype">const nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_instruction_8h.html#a3a20ca4a8f0ab220518b030cc23ffee4">CustomOp</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get rule of type nt with a given CustomOp and argument a </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
    <tr><td class="paramname">o</td><td></td></tr>
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab82ed6614e4fcced4d0e7c742e1c5e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82ed6614e4fcced4d0e7c742e1c5e4b">&#9670;&nbsp;</a></span>get_rule() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_rule.html">Rule</a>* Grammar::get_rule </td>
          <td>(</td>
          <td class="paramtype">const nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_instruction_8h.html#af2fb7c87c5854c5733d7bb0506b06de7">BuiltinOp</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get rule of type nt with a given BuiltinOp and argument a </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
    <tr><td class="paramname">o</td><td></td></tr>
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae0198e1a6c052fad5cba950e0ad60d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0198e1a6c052fad5cba950e0ad60d67">&#9670;&nbsp;</a></span>get_rule() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_rule.html">Rule</a>* Grammar::get_rule </td>
          <td>(</td>
          <td class="paramtype">const nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a rule based on s, which must uniquely be a prefix of the rule's format of a given nonterminal type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="adecdec03b3211bd3b6800511c7ed5dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecdec03b3211bd3b6800511c7ed5dd9">&#9670;&nbsp;</a></span>get_rule() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_rule.html">Rule</a>* Grammar::get_rule </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a rule based on s, which must uniquely be a prefix of the rule's format </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a607aa205d57a1b61b07f9ef57adcf697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607aa205d57a1b61b07f9ef57adcf697">&#9670;&nbsp;</a></span>lempel_ziv_full_expand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> Grammar::lempel_ziv_full_expand </td>
          <td>(</td>
          <td class="paramtype">nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_numerics_8h.html#a9fe2bbca873b046b2bd276fc6856bb88">enumerationidx_t</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>root</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98fd19c7b9c1d92c59365a693ec12547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98fd19c7b9c1d92c59365a693ec12547">&#9670;&nbsp;</a></span>lempel_ziv_full_expand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> Grammar::lempel_ziv_full_expand </td>
          <td>(</td>
          <td class="paramtype">nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_integerized_stack.html">IntegerizedStack</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>root</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11f1788026f68e7ddb7fca1ec04915f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f1788026f68e7ddb7fca1ec04915f5">&#9670;&nbsp;</a></span>log_probability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Grammar::log_probability </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the log probability of a tree according to the grammar </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a5d60795be5b288d74a87f2cc52008f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d60795be5b288d74a87f2cc52008f71">&#9670;&nbsp;</a></span>makeNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> Grammar::makeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule.html">Rule</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to create a node according to this grammar. This is how nodes get their log probabilities. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae9115c2743b054ec44ef513843d84f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9115c2743b054ec44ef513843d84f5d">&#9670;&nbsp;</a></span>neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Grammar::neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5c9afa0e7e1aa989b54402b02a677a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c9afa0e7e1aa989b54402b02a677a3">&#9670;&nbsp;</a></span>nt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr nonterminal_t Grammar::nt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>template function giving the index of its template argument (index in FLEET_GRAMMAR_TYPES). NOTE: The names here are decayed (meaning that references and base types are the same.</p>

</div>
</div>
<a id="a2182b3ded5171ba3e84be952176798e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2182b3ded5171ba3e84be952176798e9">&#9670;&nbsp;</a></span>rule_normalizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Grammar::rule_normalizer </td>
          <td>(</td>
          <td class="paramtype">const nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normalizing constant (NOT log) for all rules of type nt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a50c30e020e54743d5ede0ca9469fdb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c30e020e54743d5ede0ca9469fdb91">&#9670;&nbsp;</a></span>sample_rule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_rule.html">Rule</a>* Grammar::sample_rule </td>
          <td>(</td>
          <td class="paramtype">const nonterminal_t&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Randomly sample a rule of type nt. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa3c730ea64c8ca5d93fecb4275f2e380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c730ea64c8ca5d93fecb4275f2e380">&#9670;&nbsp;</a></span>show()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Grammar::show </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;#&#160;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Show the grammar by printing each rule</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aae1036bcd35025ff7512252c7aa06e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1036bcd35025ff7512252c7aa06e9c">&#9670;&nbsp;</a></span>rules</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_rule.html">Rule</a>&gt; Grammar::rules[N_NTs]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af55b1376566113fecd05b2c99b9f0014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55b1376566113fecd05b2c99b9f0014">&#9670;&nbsp;</a></span>Z</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Grammar::Z[N_NTs]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_grammar_8h_source.html">Grammar.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
