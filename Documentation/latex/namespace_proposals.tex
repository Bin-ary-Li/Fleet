\hypertarget{namespace_proposals}{}\section{Proposals Namespace Reference}
\label{namespace_proposals}\index{Proposals@{Proposals}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
double \hyperlink{namespace_proposals_a73f20ef1547bc5beef3e6e3adad2139c}{can\+\_\+resample} (const \hyperlink{class_node}{Node} \&n)
\item 
std\+::pair$<$ \hyperlink{class_node}{Node}, double $>$ \hyperlink{namespace_proposals_a46b497d7c2d664181240aed4cc92ad73}{prior\+\_\+proposal} (\hyperlink{class_grammar}{Grammar} $\ast$grammar, const \hyperlink{class_node}{Node} \&from)
\item 
std\+::pair$<$ \hyperlink{class_node}{Node}, double $>$ \hyperlink{namespace_proposals_a186662fcd0316b831a4a08a8e64020b3}{regenerate} (\hyperlink{class_grammar}{Grammar} $\ast$grammar, const \hyperlink{class_node}{Node} \&from)
\item 
std\+::pair$<$ \hyperlink{class_node}{Node}, double $>$ \hyperlink{namespace_proposals_a7286635ba7407c6f47a6cde53b832741}{insert\+\_\+tree} (\hyperlink{class_grammar}{Grammar} $\ast$grammar, const \hyperlink{class_node}{Node} \&from)
\item 
std\+::pair$<$ \hyperlink{class_node}{Node}, double $>$ \hyperlink{namespace_proposals_a5359114c687c89b35ba672b9d4b3c7ad}{delete\+\_\+tree} (\hyperlink{class_grammar}{Grammar} $\ast$grammar, const \hyperlink{class_node}{Node} \&from)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespace_proposals_a73f20ef1547bc5beef3e6e3adad2139c}\label{namespace_proposals_a73f20ef1547bc5beef3e6e3adad2139c}} 
\index{Proposals@{Proposals}!can\+\_\+resample@{can\+\_\+resample}}
\index{can\+\_\+resample@{can\+\_\+resample}!Proposals@{Proposals}}
\subsubsection{\texorpdfstring{can\+\_\+resample()}{can\_resample()}}
{\footnotesize\ttfamily double Proposals\+::can\+\_\+resample (\begin{DoxyParamCaption}\item[{const \hyperlink{class_node}{Node} \&}]{n }\end{DoxyParamCaption})}

Helper function for whether we can resample from a node (just accesses n.\+can\+\_\+resample) 
\begin{DoxyParams}{Parameters}
{\em n} & -\/ what node are we asking about? \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ a double (1.\+0 or 0.\+0) depending on whether n can be sampled
\end{DoxyReturn}
\mbox{\Hypertarget{namespace_proposals_a5359114c687c89b35ba672b9d4b3c7ad}\label{namespace_proposals_a5359114c687c89b35ba672b9d4b3c7ad}} 
\index{Proposals@{Proposals}!delete\+\_\+tree@{delete\+\_\+tree}}
\index{delete\+\_\+tree@{delete\+\_\+tree}!Proposals@{Proposals}}
\subsubsection{\texorpdfstring{delete\+\_\+tree()}{delete\_tree()}}
{\footnotesize\ttfamily std\+::pair$<$\hyperlink{class_node}{Node}, double$>$ Proposals\+::delete\+\_\+tree (\begin{DoxyParamCaption}\item[{\hyperlink{class_grammar}{Grammar} $\ast$}]{grammar,  }\item[{const \hyperlink{class_node}{Node} \&}]{from }\end{DoxyParamCaption})}

backward is we choose the {\itshape new} s, then generate everything else, and choose anything equal \mbox{\Hypertarget{namespace_proposals_a7286635ba7407c6f47a6cde53b832741}\label{namespace_proposals_a7286635ba7407c6f47a6cde53b832741}} 
\index{Proposals@{Proposals}!insert\+\_\+tree@{insert\+\_\+tree}}
\index{insert\+\_\+tree@{insert\+\_\+tree}!Proposals@{Proposals}}
\subsubsection{\texorpdfstring{insert\+\_\+tree()}{insert\_tree()}}
{\footnotesize\ttfamily std\+::pair$<$\hyperlink{class_node}{Node}, double$>$ Proposals\+::insert\+\_\+tree (\begin{DoxyParamCaption}\item[{\hyperlink{class_grammar}{Grammar} $\ast$}]{grammar,  }\item[{const \hyperlink{class_node}{Node} \&}]{from }\end{DoxyParamCaption})}

backward is we choose t exactly, then we pick anything below that is equal to s \mbox{\Hypertarget{namespace_proposals_a46b497d7c2d664181240aed4cc92ad73}\label{namespace_proposals_a46b497d7c2d664181240aed4cc92ad73}} 
\index{Proposals@{Proposals}!prior\+\_\+proposal@{prior\+\_\+proposal}}
\index{prior\+\_\+proposal@{prior\+\_\+proposal}!Proposals@{Proposals}}
\subsubsection{\texorpdfstring{prior\+\_\+proposal()}{prior\_proposal()}}
{\footnotesize\ttfamily std\+::pair$<$\hyperlink{class_node}{Node},double$>$ Proposals\+::prior\+\_\+proposal (\begin{DoxyParamCaption}\item[{\hyperlink{class_grammar}{Grammar} $\ast$}]{grammar,  }\item[{const \hyperlink{class_node}{Node} \&}]{from }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespace_proposals_a186662fcd0316b831a4a08a8e64020b3}\label{namespace_proposals_a186662fcd0316b831a4a08a8e64020b3}} 
\index{Proposals@{Proposals}!regenerate@{regenerate}}
\index{regenerate@{regenerate}!Proposals@{Proposals}}
\subsubsection{\texorpdfstring{regenerate()}{regenerate()}}
{\footnotesize\ttfamily std\+::pair$<$\hyperlink{class_node}{Node},double$>$ Proposals\+::regenerate (\begin{DoxyParamCaption}\item[{\hyperlink{class_grammar}{Grammar} $\ast$}]{grammar,  }\item[{const \hyperlink{class_node}{Node} \&}]{from }\end{DoxyParamCaption})}

Regenerate with a rational-\/rules (Goodman et al.) style regeneration proposal\+: pick a node uniformly and regenerate it from the grammar. 
\begin{DoxyParams}{Parameters}
{\em grammar} & -\/ what grammar to use \\
\hline
{\em from} & -\/ what node are we proposing from \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pair of the new proposed tree and the forward-\/backward log probability (for use in M\+C\+MC)
\end{DoxyReturn}
