\hypertarget{_primitives_8h}{}\section{src/\+Virtual\+Machine/\+Primitives.h File Reference}
\label{_primitives_8h}\index{src/\+Virtual\+Machine/\+Primitives.\+h@{src/\+Virtual\+Machine/\+Primitives.\+h}}


A preprimitive is a class that primitives inherit. We use a static op\+\_\+counter so that at compile time thsi can be used to compute an op number for each separate primitive.  


{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$cstdlib$>$}\newline
{\ttfamily \#include $<$functional$>$}\newline
{\ttfamily \#include $<$tuple$>$}\newline
{\ttfamily \#include $<$assert.\+h$>$}\newline
{\ttfamily \#include \char`\"{}Instruction.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}Template\+Magic.\+h\char`\"{}}\newline
Include dependency graph for Primitives.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_primitives_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_primitives_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{struct_pre_primitive}{Pre\+Primitive}
\item 
class \hyperlink{struct_primitive}{Primitive$<$ T, args $>$}
\end{DoxyCompactItemize}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespace_fleet_1_1apply_v_m_s}{Fleet\+::apply\+V\+MS}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$int n, class T , typename V , typename P , typename L $>$ }\\\hyperlink{_instruction_8h_a6202215407ab29590bb936ca2996cf64}{vmstatus\+\_\+t} \hyperlink{namespace_fleet_1_1apply_v_m_s_a7961ca5a819b4db7e4261f7ff18d272d}{Fleet\+::apply\+V\+M\+S\+::apply\+To\+V\+M\+S\+\_\+one} (T \&p, V $\ast$vms, P $\ast$pool, L $\ast$loader)
\item 
{\footnotesize template$<$class T , typename V , typename P , typename L , size\+\_\+t... Is$>$ }\\\hyperlink{_instruction_8h_a6202215407ab29590bb936ca2996cf64}{vmstatus\+\_\+t} \hyperlink{namespace_fleet_1_1apply_v_m_s_a7309104b033509b889fd07bff2dc5ff4}{Fleet\+::apply\+V\+M\+S\+::apply\+To\+V\+MS} (T \&p, int index, V $\ast$vms, P $\ast$pool, L $\ast$loader, std\+::index\+\_\+sequence$<$ Is... $>$)
\item 
{\footnotesize template$<$class T , typename V , typename P , typename L $>$ }\\\hyperlink{_instruction_8h_a6202215407ab29590bb936ca2996cf64}{vmstatus\+\_\+t} \hyperlink{_primitives_8h_a99488b23e9756ffef54d78db8a7e6d2e}{apply\+To\+V\+MS} (T \&p, int index, V $\ast$vms, P $\ast$pool, L $\ast$loader)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A preprimitive is a class that primitives inherit. We use a static op\+\_\+counter so that at compile time thsi can be used to compute an op number for each separate primitive. 

A primitive associates a string name (format) with a function, and allows grammars to extract all the relevant function pieces via constexpr, and also defines a V\+MS function that can be called in dispatch op here is generated uniquely for each \hyperlink{struct_primitive}{Primitive}, which is how \hyperlink{class_l_o_t_hypothesis}{L\+O\+T\+Hypothesis} knows which to call. SO\+: grammars use this op (statically updated) in nodes, and then when they are linearized the op is processed in a switch statement to evaluate This is a funny intermediate type that essentially helps us associate functions, formats, and nonterminal types all together.

\subsection{Function Documentation}
\mbox{\Hypertarget{_primitives_8h_a99488b23e9756ffef54d78db8a7e6d2e}\label{_primitives_8h_a99488b23e9756ffef54d78db8a7e6d2e}} 
\index{Primitives.\+h@{Primitives.\+h}!apply\+To\+V\+MS@{apply\+To\+V\+MS}}
\index{apply\+To\+V\+MS@{apply\+To\+V\+MS}!Primitives.\+h@{Primitives.\+h}}
\subsubsection{\texorpdfstring{apply\+To\+V\+M\+S()}{applyToVMS()}}
{\footnotesize\ttfamily template$<$class T , typename V , typename P , typename L $>$ \\
\hyperlink{_instruction_8h_a6202215407ab29590bb936ca2996cf64}{vmstatus\+\_\+t} apply\+To\+V\+MS (\begin{DoxyParamCaption}\item[{T \&}]{p,  }\item[{int}]{index,  }\item[{V $\ast$}]{vms,  }\item[{P $\ast$}]{pool,  }\item[{L $\ast$}]{loader }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

